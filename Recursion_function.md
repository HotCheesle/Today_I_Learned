# 재귀함수
> ## 재귀 함수는 함수의 내부에서 자기 자신을 호출하는 함수를 말한다.
- 재귀함수의 장점
  - 
  - 복잡한 문제를 간결하고 직관적으로 표현 가능하게 한다.
  - 상황에 따라 반복문보다 코드의 길이를 줄여주고 간결하고 명확하게 표현할 수 있다.
  - 문제를 작은 문제로 나누어서 해결하는 구조를 쉽게 구현할 수 있다.
  - 수학적 정의가 점화식으로 표현 가능할 경우 쉽게 구현할 수 있다.
- 재귀함수의 단점
  - 
  - 재귀함수의 종료지점이 명확하지 않을 경우 스택 오버플로우가 발생할 수 있다.
  - 함수는 스택에 저장이 되므로 재귀 깊이가 지나치게 깊어질 경우 스택 오버플로우가 발생할 수 있다.
  - 반복문에 비해 메모리 사용량이 많고 속도가 느리다.
  - 함수가 지속적으로 호출이 되는 것이므로 오버헤드가 크다.
  - 복잡한 재귀함수의 경우 오히려 코드 가독성이 떨어진다.
```python
def factorial(n):
  if n == 1: 
    return 1 
  return n * factorial(n-1)

result = factorial(5)
print(result)
>> 120
```
- 위의 재귀함수 `factorial()`의 경우 함수 내부에서 자기 자신을 호출하고 있다. 이때 호출할 때마다 입력받은 수 보다 1작은 값을 인수로 넣고있으므로 종료조건 `n == 1`에 수렴한다. 만약 좀더 안전하게 만들고 싶다면 `n <= 1`로 범위를 늘려도 상관없다. 
- 따라서 위의 함수는 4번 재귀적으로 호출된 뒤 종료가 된다.
- 위의 경우를 예시로 재귀적으로 호출되는 과정을 살펴보면
> `factorial(5)` n = 5 -> return 5 * 24←┐
>> `factorial(5-1)` n = 4 -> return 4 * 6←┐
>>> `factorial(4-1)` n = 3 -> return 3 * 2←┐
>>>> `factorial(3-1)` n = 2 -> return 2 * 1
>>>>> `factorial(2-1)` n = 1 　 　　 　↑ \
        `if n == 1 -> true` -> return 1 ┘
- 재귀 호출 4번을 한뒤 n = 1이 되어서 1을 return 하고 연쇄적으로 계산이 되어서 바깥쪽 함수로 나가고 있다.

- factorial을 재귀적으로 구현할 수 있는 이유는 팩토리얼의 정의에 있다.
> 팩토리얼의 정의: n 보다 작거나 같은 모든 양의 정수의 곱
- 위와 같은 정의 이므로 이를 수식으로 나타내면 다음과 같이 나타낼 수 있을 것이다.
> n! = 1 * 2 * 3 * ... * n-1 * n
- 그럼 (n+1)!은 어떻게 표현할 수 있을까
> (n+1)! = 1 * 2 * 3 * ... * n-1 * n * (n+1)
- 이 수식은 다음과 같이 표현할 수도 있다.
> (n+1)! = n! * (n+1)
- 즉 다음과 같은 점화식으로 나타낼 수 있다.
> a_n+1 = a_n * (n+1)