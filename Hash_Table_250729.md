# 해시 테이블
> 해시 테이블은 키와 값을 연결하여 저장하는 데이터 구조로 키를 통해 값이 저장되어있는 인덱스를 가르키도록 되어있어 데이터를 검색하거나 중복 확인을 할때 O(1)밖에 걸리지 않는 굉장히 빠른 데이터 구조이다.
- 해시 테이블의 구조
    - 
- 버킷(Buckets)
    - 데이터를 담아두는 공간으로 값마다 인덱싱이 되어있어 데이터를 바로 찾을 수 있다.
- 해시 함수(hash function)
    - 키를 넣으면 데이터의 해시 값으로 바로 변환시켜주는 함수로 해시 함수는 모든 서로다른 키 값에 대해 서로다른 해시 값으로 변환해야 한다. 
- 해시 값(hash value)
    - 키를 해시 함수를 통해 생성한 값으로 이 해시 값을 기반으로 데이터에 접근한다. 
    - 파이썬의 경우 해시 값은 긴 정수값이다. 정수값이므로 파이썬은 정수 데이터를 해싱해야 할때는 일정 크기 아래로는 정수 데이터 그대로를 해시 값으로 사용하고 있고, 그 위로는 간단한 연산을 거친 값을 해시 값으로 사용하고 있다. 
    - 문자열의 경우 파이썬 인터프리터가 시작될때 결정되는 난수인 난수 시드값에 따라 해시 난수화가 적용 되므로 실행 마다 순서가 바뀐다.
    - 이때문에 재미있는 현상이 나타나는데 해시를 사용하는 데이터 타입(딕셔너리, 셋)의 경우 pop()을 사용하면 데이터 내의 임의의 값을 반환하는데 정수값이 pop되는경우 정수끼리는 항상 어떤 순서가 생기는 것을 확인할 수 있다.
    ```python
    my_set = {1, 3, 5, 2, 4, 10}
    for i in range(6): 
        print(my_set.pop(), end=' ')
    >> 1 2 3 4 5 10 # 1회차 출력
    >> 1 2 3 4 5 10 # 2회차 출력
    >> 1 2 3 4 5 10 # 3회차 출력
    ```
    - 정수가 아닌 다른 값의 경우 매 실행마다 순서가 달라지는것을 확인할 수 있다.
    ```python
    my_set = {'A', 'B', 'C', 'D', 'E', 'F'}
    for i in range(6): 
        print(my_set.pop(), end=' ')
    >> B E F C A D # 1회차 출력
    >> B F E D C A # 2회차 출력
    >> B C D E A F # 3회차 출력
    ```
    - 위의 실행결과를 얼핏보면 무작위 인것 같지만 항상 'B'가 앞에 나오고 'A'는 뒤에서만 나오는 등 완전하게 무작위는 아닌것 같아 보인다. 
    - 실제로 파이썬 공식문서에는 딕셔너리와 셋의 pop()메소드에 대해 임의의 값을 리턴한다고 설명한뒤 '임의의 값'은 '랜덤한 값'과는 다르다고 말하고 있다. 이는 파이썬 내장 해시 함수에 의해 딕셔너리와 셋을 저장하므로 약간의 규칙성은 생길 수 있다는 것이다.
- 해시 테이블의 구현
    -
    - 해시라는 것이 키 값을 고유의 해시 값으로 변환하여 이를 기반으로 데이터를 저장하는 것이므로 키를 어떤 조작을 하여 각각 다른 값을 내도록 하는 함수를 이용하여 데이터를 저장하면 그것이 바로 해시 테이블이다. 
    ```python
    buckets = [None for _ in range(100)]

    def hash_function(key): 
        key_list = list(str(key))
        tot = 0
        for k in key_list: 
            tot += ord(k)
        tot %= 100
        return tot

    def hash_add(key, value): 
        index = hash_function(key)
        buckets[index] = value

    def hash_pop(key): 
        index = hash_function(key)
        value = buckets[index]
        buckets[index] = None
        return value
    ```
    - 간단하게 해시 함수와 저장 및 출력을 구현해 보았다. 해시 함수는 키값으로 받은 str을 각 글자를 유니코드로 변경하여 모두 더한 뒤 100으로 나눈 나머지를 인덱스로 사용해 보았다.
    ```python
    hash_add('country', '대한민국')
    hash_add('status', '공부중!')
    hash_add('Language', 'Python')

    print(buckets)
    >> [None, ..., 'Python', ..., '공부중!', ..., '대한민국', ..., None]
    ```
    - 'country', 'status', 'Language'를 키로 해싱을 했는데 다행히도 모두 다 다른 해시 값을 가져서 버킷에 잘 들어간 것을 볼 수 있다. 이제 출력을 해보면 
    ```python
    print(hash_pop('Language'))
    print(hash_pop('country'))
    print(hash_pop('status'))
    >> Python
    >> 대한민국
    >> 공부중!
    ```
    - 이처럼 출력도 해시 함수를 통해 버킷에서 바로 꺼내올 수 있다. 해시는 인덱스로 접근하기 때문에 버킷의 크기가 10000이 되었든 10만이 되었든 저장하고 출력하는 시간이 항상 O(1)이다.
    - 또한 키를 해시 함수에 넣어보면 해당 키가 이미 버킷에 있는지 중복 확인하기가 매우 쉽다. 
    - 이러한 특성덕분에 데이터의 추가 및 삭제, 중복확인이 많은 캐시에 해시를 사용한다.
    - 하지만 위에서 보았듯이 해시 테이블에 많은 값을 저장하려면 버킷의 크기가 커져야 한다. 하지만 버킷의 크기가 커지면 메모리를 많이 차지하게 된다. 극단적이긴 하지만 위의 경우 3개의 데이터를 저장하기 위해 버킷을 100개나 할당했다. 
    - 따라서 버킷의 크기를 늘리기 보다 적당한 크기의 버킷으로 충돌이 발생했을 때 다른 방식으로 저장하는 방법을 사용한다.