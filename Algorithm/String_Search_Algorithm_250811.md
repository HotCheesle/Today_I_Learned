# 문자열 검색 알고리즘
## KMP 검색 알고리즘
- KMP는 해당 알고리즘을 처음 고안한 연구자들의 이름에서 따왔다. 해당 알고리즘은 하나씩 모두 비교해보는 단순 비교와 달리 이미 확인한 부분을 이용하여 불필요한 확인을 건너뛴다. 
- 먼저 어떻게 건너뛰는가를 하기 전에 접두사와 접미사를 알아야 한다.
    - 접두사는 앞에서부터 i번째 까지의 서브 스트링이다.
    - 접미사는 뒤에서부터 i개 까지의 서브 스트링이다. 
    
    이렇게 말로 설명하는것 보다 예시를 직접 보면
    - 'apple'이라는 문자열이 있다면 접두사와 접미사는 다음과 같다.

    |apple|   |    |   |    |     |
    |-----|---|----|---|----|-----|
    |접두사| a | ap |app|appl|apple|
    |접미사| e | le |ple|pple|apple|

- 접두사와 접미사가 위와 같은 개념이라는 것을 알았다면 이제 이런 경우를 생각해보자. 
> 문자열을 비교하다가 서로 다르다면 달라진 위치로 건나뛰면 그 사이의 불필요한 연산을 건너뛸 수 있을것이다.
- 보통은 위와같이 건너뛰어도 크게 문제가 발생하지 않을 것이다.

    |a|p|p|a|p|a|p|p|l|e|d|p|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    |a|p|p|l| | | | | | | | |
    | | | |↑| | | | | | | | |

    |a|p|p|a|p|a|p|p|l|e|d|p|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    | | | |a|p|p| | | | | | |
    | | | | | |↑| | | | | | |

    |a|p|p|a|p|a|p|p|l|e|d|p|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    | | | | | |a|p|p|l|e| | |
    | | | | | | | | | | | | |

- 하지만 접두사와 접미사가 같은 부분이 있는 단어라면 문제가 생긴다.
- 'abcdabce'를 abcdabcdabce'에서 찾는다고 한다면 이때의 'abcdabce'는 접두사 'abc'와 동일한 접미사 'abc'가 존재하는 경우이다.
- 이제 위와같은 방법으로 건너뛰면서 문자열을 검색해보자

    |a|b|c|d|a|b|c|d|a|b|c|e|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    |a|b|c|d|a|b|c|e| | | | |
    | | | | | | | |↑| | | | |

    |a|b|c|d|a|b|c|d|a|b|c|e|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    | | | | | | | |a| | | | |
    | | | | | | | |↑| | | | |

    |a|b|c|d|a|b|c|d|a|b|c|e|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    | | | | | | | | |a|b|c|d|
    | | | | | | | | | | | |↑|

    |a|b|c|d|a|b|c|d|a|b|c|e|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    | | | | | | | | | | | |a|
    | | | | | | | | | | | |↑|

- 건너뛰다보니 분명히 'abcdabe'를 포함하고 있음에도 건너뛰는 바람에 찾을 수가 없다. 
> 그렇다면 동일한 접두사, 접미사가 포함되어 있는 경우 검사가 완료된 부분을 사용해서 이미 일치했던 접미사가 접두사와 같으니 접두사가 이미 일치했다는것이 확정 되었으므로 해당 부분 다음부터 검색을 재시작하면 정말 불필요한 검색만 건너뛸 수 있을 것이다.
- 위와 같은 아이디어로 패턴이 불일치 시 돌아갈 위치를 저장하는 LPS(Longest Prefix which is also Suffix, 가장 긴 접두사 접미사 일치 길이)배열을 만들어서 불일치가 발생하면 LPS배열에 해당하는 값으로 돌아가면 된다.
- LPS에 대해서도 직접 'abcdabce'에 대한 표로 보면 다음과 같다.

    |index| sub_string |LPS_list[index]|
    |-----|------------|---------------|
    |  0  |      a     |       0       |
    |  1  |      ab    |       0       |
    |  2  |     abc    |       0       |
    |  3  |     abcd   |       0       |
    |  4  | `a`bcd`a`  |       1       |
    |  5  | `ab`cd`ab` |       2       |
    |  6  |`abc`d`abc` |       3       |
    |  7  |`abc`d`abc`e|       3       |

- 이러한 LPS 리스트를 생성했다면 이제 이것을 어떻게 이용해야 될까 
> 만약 'abcda' 까지는 일치하였고 다음 문자에서 불일치가 발생했다면 a가 일치하므로 a다음부터 확인하는것이 아닌 a를 접두사로 가정하고 이 다음부터 검색을 하면 될 것이다.

- 이제 좀 전에는 찾지 못했던 상황에서 LPS를 이용하여 검색을 해보자

    |`a`|`b`|`c`|d|`a`|`b`|`c`|d|a|b|c|e|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    |`a`|`b`|`c`|d|a|b|c|e| | | | |
    | | | | | | | |↑| | | | |

    이때 abc가 일치하므로 처음부터 검색하는 것이 아니라 이전의 abc는 이미 일치한것이므로 이후부터 검색한다.

    |a|b|c|d|`a`|`b`|`c`|d|a|b|c|e|
    |-|-|-|-|-|-|-|-|-|-|-|-|
    | | | | |`a`|`b`|`c`|d|a|b|c|e|
    | | | | | | | | | | | | |

- KMP를 이용하면 아까 놓쳤던 부분을 찾을 수 있다. 이제 이부분을 실제 코드로 구현해보면 
```python
def get_LPS(string): # 접두사와 접미사가 일치하는 최대길이
    n = len(string)
    LPS_list = [0 for _ in range(n)] # 반환할 LPS리스트
    for i in range(2, n+1):
        sub = string[:i] # 서브스트링의 길이를 2부터 1씩 늘려나가면서 LPS찾기
        for s in range(i-1): 
            if sub[s] != sub[s+1]: # 0~i까지 모두 같은 문자면 0으로
                break 
        else: 
            continue # 이부분은 개선의 여지가 있음 AAA면 003 이런식으로
        left, right, cnt, max_cnt = 0, 0, 0, 0 # 접두사 부분이랑 접미사 부분을 반으로 나눔
        if i % 2 == 0: # 짝수면 그대로 홀수면 right 올림처리를 해줘야 함
            right = i // 2
            for j in range(right): # 절반만큼 반복
                if sub[left] == sub[right+j]: # 같으면 left를 당기면서 카운트
                    cnt += 1
                    left += 1
                else: # 아니라면 최대값 갱신 후 초기화
                    if max_cnt < cnt: 
                        max_cnt = cnt
                        cnt = 0
        else: 
            right = (i // 2) + 1 # 홀수 올림 처리
            for j in range(right-1): # 반복횟수는 -1 해줘야함
                if sub[left] == sub[right+j]: 
                    cnt += 1
                    left += 1
                else: 
                    if max_cnt < cnt: 
                        max_cnt = cnt
                        cnt = 0
        if max_cnt < cnt: max_cnt = cnt # 마지막에도 한번 더 최대값 갱신
        LPS_list[i-1] = max_cnt
    return LPS_list

def kmp_search(find_str, str_in_here): 
    lps = get_LPS(find_str)
    find_idx, idx = 0, 0
    while idx < len(str_in_here): # 찾을 곳의 인덱스 끝까지 반복
        if str_in_here[idx] == find_str[find_idx]: # 둘이 같다면 인덱스 1씩 증가
            find_idx += 1
        else: # 다른경우 lps상의 인덱스로 후퇴(lps의 인덱스는 0이 아닐경우 접두사와 접미사가 일치하는 부분이 있다는 것이다.)
            find_idx = lps[find_idx-1] # 지금까지 일치했던 곳(현재 find_idx에서 틀렸으므로 find_idx-1까지는 일치했다는 뜻)
            if find_idx != 0: # 일치가 존재할 경우 해당 idx를 다시 확인 해야 하므로 -1해줘야 한다.
                idx -= 1
        idx += 1
        if find_idx >= len(find_str): # 만약 찾을 텍스트의 길이를 초과하여 일치(전원일치)하면 시작 인덱스를 반환
            return idx - len(find_str)
    return -1 # 텍스트를 찾지 못했다면 -1 리턴

print(kmp_search('ABCDABE', 'ABCDABCDABEE'))

>> 4
```
