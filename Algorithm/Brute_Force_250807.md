# 브루트 포스(완전탐색)
## 브루트 포스란
- **가능한 모든 경우의 수를 탐색하는 알고리즘**으로 말 그대로 무식하게 대입하는 방법이나 범위 내에 해가 존재하고 충분한 시간이 주어진다면 **100% 확률**로 해를 구할 수 있다. 
- 가장 떠올리기 쉬운 알고리즘으로 모든 문제풀이의 출발점이다. 가장 직관적이고 구현 난이도가 쉽다는 장점이 있다. 무엇보다도 정확도가 100% 이므로 브루트 포스가 가능하다면 **문제풀이에는** 사용하는 것이 좋다.(시간/공간 복잡성은 최소만 만족하면 되기 때문)
- 제약사항
    - 
    - 브루트 포스는 시간복잡도 측면에서는 효율이 매우 안좋기 때문에 범위가 지나치게 크면 사용하지 못한다는 제약이 있다. 
    - 또한 찾은 답이 정답인지 확인할 수 있어야 한다. 모든 경우의 수를 대입해 봤으나 어떤것이 정답인지 구분하지 못한다면 브루트 포스를 사용하는 의미가 없다.

## 브루트 포스를 사용한 문제 예시
> 플랫폼: `백준` 문제번호: `2503` 문제제목: `숫자야구` 사용 알고리즘: `브루탈 포스` \
> 링크: https://www.acmicpc.net/problem/2503

문제
- 
현재 민혁이와 영수는 숫자야구 게임을 하고 있는 도중에 있다. 민혁이가 영수에게 어떤 수들을 물어보았는지, 그리고 각각의 물음에 영수가 어떤 대답을 했는지가 입력으로 주어진다. 이 입력을 바탕으로 여러분은 영수가 생각하고 있을 가능성이 있는 수가 총 몇 개인지를 알아맞혀야 한다.

아래와 같은 경우를 생각해보자.  

- 민혁: 123
- 영수: 1 스트라이크 1 볼.
- 민혁: 356
- 영수: 1 스트라이크 0 볼.
- 민혁: 327
- 영수: 2 스트라이크 0 볼.
- 민혁: 489
- 영수: 0 스트라이크 1 볼.

이때 가능한 답은 324와 328, 이렇게 두 가지이다. \
영수의 답들에는 모순이 없다고 가정한다. 

민혁이의 물음들과 각각의 물음에 대한 영수의 답이 입력으로 주어질 때 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력하는 프로그램을 작성하시오.

입력
- 
첫째 줄에는 민혁이가 영수에게 몇 번이나 질문을 했는지를 나타내는 1 이상 100 이하의 자연수 N이 주어진다. 이어지는 N개의 줄에는 각 줄마다 민혁이가 질문한 세 자리 수와 영수가 답한 스트라이크 개수를 나타내는 정수와 볼의 개수를 나타내는 정수, 이렇게 총 세 개의 정수가 빈칸을 사이에 두고 주어진다.

출력
- 
첫 줄에 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력한다.

---

>- 먼저 처음 접근은 0부터 9까지의 배열을 만들고 스도쿠 메모형식으로 가능한 경우의 수를 입력하려고 했으나 이후 이걸 가지고 조합을 할 생각을 하니 도저히 방법이 떠오르지 않아서 이 방법은 날려버렸다.

>- 두번째 떠올린 방법은 가능한 모든 숫자 조합을 일일히 대입해 보는것이다. 민혁이가 부른 숫자와 비교하여 나온 스트라이크와 볼 개수가 영수가 대답한 스트라이크와 볼 개수와 동일하다면 해당 숫자는 가능성이 있는 답이 될것이다. 

>- 먼저 조합 가능한 숫자는 1~9까지의 숫자이고 서로 중복이 되지 않는다. 따라서 리스트 컴프리핸션을 통해 조합 가능한 숫자 리스트를 생성하고 갯수를 세어보니 총 504가지였다. 이 숫자를 보고 브루트 포스로 접근해도 되겠다는 생각이 확 들었다. 따라서 이 아이디어로 코드를 짜보았다.

```python
numbers = {str(i) + str(j) + str(k) # 1~9 사이 문자 'i', 'j', 'k' 를 합친다.
           for i in range(1, 10) 
           for j in range(1, 10) 
           for k in range(1, 10) 
           if i != j and j != k and i != k} # 단 서로 다 달라야 한다
rm_list = []

def num_baseball(possible, call): # possible이 정답일 때 call과의 스트라이크 볼 개수 반환
    strike, ball = 0, 0
    for i in range(3): 
        if possible[i] == call[i]: 
            strike += 1
        elif call[i] in possible:
            ball += 1

    return str(strike), str(ball) 

n = int(input())
for i in range(n): 
    call_num, *count = input().split() # ['숫자'] 와 ['스트라이크', '볼'] 의 형태로 받음
    call_num = list(call_num) # ['i', 'j', 'k'] 형태로 변환
    for nums in numbers: 
        possi_num = list(nums) # ['i', 'j', 'k'] 형태로 변환
        result_count = num_baseball(possi_num, call_num) 
        if count != list(result_count): # 스트라이크 볼 개수 비교
            rm_list.append(nums) # 다르면 삭제
    for rm in rm_list: 
        numbers.discard(rm)
    rm_list.clear()

print(len(numbers))
```
- 숫자야구는 각 자리수를 따로 봐야하기 때문에 숫자보다 문자열로 다루는게 좋을것 같아서 input과 생성한 숫자 모두 문자열이 들어있는 리스트로 변환했다. 
- 지금 보니 문자열도 인덱스가 있는 Sequence형 자료형이라 굳이 리스트로 형변환을 하지 않아도 되었을것 같다.
- 또한 삭제에 용이하도록 `set`을 통해 삭제해 나가려 했으나 `for`문으로 순회중에 `set`의 사이즈가 변하면 바로 `exception`이 발생해서 별도의 삭제할 목록 리스트를 생성하고 순회가 끝난뒤 일괄적으로 삭제하는 방식으로 변경하였다.

>- 이렇게 가능한 모든 경우의 수를 대입하면서 답을 도출해내는 알고리즘이 바로 브루트 포스이다. 