# 누적합 알고리즘(Prefix Sum)
- 누적합 알고리즘은 배열에서 구간의 합을 빠르게 구하기 위해 이전 까지의 누적 합을 사용하는 방식으로 일종의 DP적인 알고리즘이다. 
- 어떤 배열에서 구간을 구하려고 한다면 직접 해당 구간을 순회하면서 누적하여 더하면 구할 수 있을 것이다. 하지만 배열이 매우 크고 구해야 하는 구간이 넓다면 직접 순회하는 방법은 1차원 배열이라면 O(N), 2차원이라면 O(N^2)이 걸릴 것이다.
- 직접 계산하는것은 너무 오래 걸리니 처음에 한번만 각각의 누적합을 구해두면 다음에 구간합을 구할 때는 구간의 끝의 누적합 - 구간의 시작-1의 누적합을 통해 아주 간편하게 O(1)로 구간합을 구할 수 있다. 
- 직접 보면서 좀더 자세히 말해보자면
```python
arr = [i for i in range(100)] # [1, 2, 3, ... , 99, 100]
prefix_arr = [0 for _ in range(100)]
prefix_arr[0] = arr[0]
for i in range(1, 100): 
    prefix_arr[i] = prefix_arr[i-1] + arr[i]
```
- 위와 같은 상황에서 45부터 83까지의 구간 합을 구하는 상황을 생각해보자
```python
tot = 0
for i in range(44, 83): 
    tot += arr[i]
```
- 위의 코드는 구간을 직접 순회하면서 `tot`에 누적합을 더하는 방식이다. 위의 경우는 구간이 짧아서 크게 상관이 없지만 만약 구간이 100만개쯤 된다면 계산하는데 상당한 시간이 걸릴것이다.
- 이제 같은 계산을 미리 계산해둔 누적합을 이용하면 다음과 같다.
```python
tot = prefix_arr[83] - prefix_arr[43]
```
- 미리 계산해둔 누적합을 사용하니 단 한번의 연산만으로 구간합을 구할 수 있다. 이는 구간이 10만이 되었든 1000만이 되었든 단 한번의 연산만으로 계산할 수 있다는 매우 강력한 알고리즘이다. 

### 단점
- 이렇게 강력해 보이는 알고리즘임에도 단점은 존재한다. 
- 먼저 값이 담겨있는 배열의 크기와 동일한 누적합 배열이 하나 더 필요하다. 이는 배열이 클 경우 공간을 많이 차지하게 된다.
- 그리고 누적합을 초기에 계산을 해야하기 때문에 오버헤드가 있다. 
- 배열이 변하지 않아야 한다. 만약 배열이 수정된다면 누적합에 반영하기 위해 다시 갱신해야 한다.

## 2차원 리스트 에서의 구간합
- 1차원과 달리 2차원 리스트에서의 누적합은 `arr[i][j]` 의 경우 `arr[0][0]`부터 가로 j, 세로 i만큼의 영역 전체의 합과 같다.
```python
arr =  [[ 1,  2,  3,  4,  5], 
        [ 6,  7,  8,  9, 10], 
        [11, 12, 13, 14, 15], 
        [16, 17, 18, 19, 20], 
        [21, 22, 23, 24, 25]]

# prefix_arr[2][2] = 1 + 2 + 3 + 6 + 7 + 8 + 11 + 12 + 13 = 63
```
- 위 처럼 2차원 배열에서는 해당 인덱스 까지 원점에서부터 사각형 모양의 범위의 합이다.
- 이러한 누적합을 빠르게 구하기 위해서는 arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1] 로 구하면 된다.
---
- 누적합 범위
    - 
    | A | A | A | - | - |
    |---|---|---|---|---|
    | A | A | A | - | - |
    | A | A | T | - | - |
    | - | - | - | - | - |
    | - | - | - | - | - |

- T의 누적합은 T와 A부분의 전체 합이다.

- 2차원 배열에서의 누적합 구하기
    -

    | C | C | B | - | - |
    |---|---|---|---|---|
    | C |T_C|T_B| - | - |
    | A |T_A| T | - | - |
    | - | - | - | - | - |
    | - | - | - | - | - |

- 누적합 T는 arr에서의 T위치 값 + T_B + T_A - T_C 로 구할 수 있다. T_A는 C부분과 A의 합, T_B는 C부분과 B의 합이므로 둘을 더하면 C부분이 중복으로 더해진다. 따라서 C부분의 합인 T_C를 한번 빼주는 것이다.

- 2차원 배열에서의 구간 합 구하기
    - 
    | C | C | B | B | - |
    |---|---|---|---|---|
    | C |T_C| B |T_B| - |
    | A | A | T | T | - |
    | A |T_A| T |T_T| - |
    | - | - | - | - | - |

- T구간의 합을 구하기 위해서는 T_T - T_A - T_B + T_C로 구할 수 있다. 마찬가지로 T_T는 T와 A, B, C의 합이고 T_A는 A와 C의 합, T_B는 B와 C의 합 이므로 T_T 에서 T_A와 T_B를 빼면 C구간이 중복해서 빼지므로 T_C를 한번 더해주면 T구간의 합이 구해지게 된다.

- 이제 위의 과정을 코드로 살펴보면
```python
arr =  [[ 1,  2,  3,  4,  5], 
        [ 6,  7,  8,  9, 10], 
        [11, 12, 13, 14, 15], 
        [16, 17, 18, 19, 20], 
        [21, 22, 23, 24, 25]]

prefix_arr = list(list(0 for _ in range(5)) for _ in range(5))
prefix_arr[0][0] = arr[0][0]
for i in range(1, 5): 
    prefix_arr[0][i] = prefix_arr[0][i-1] + arr[0][i]
    prefix_arr[i][0] = prefix_arr[i-1][0] + arr[i][0]
for row in range(1, 5): 
    for col in range(1, 5): 
        prefix_arr[row][col] = arr[row][col] +  prefix_arr[row-1][col] + prefix_arr[row][col-1] - prefix_arr[row-1][col-1]

print(prefix_arr)

>> [[1,   3,   6,  10,  15],
>> [ 7,  16,  27,  40,  55],
>> [18,  39,  63,  90, 120],
>> [34,  72, 114, 160, 210],
>> [55, 115, 180, 250, 325]]
```

- `[2][2]` 부터 `[3][3]` 까지의 정사각형 구간의 합을 구해보면
```python
tot = prefix_arr[3][3] - prefix_arr[1][3] - prefix_arr[3][1] + prefix_arr[1][1]
print(tot)
>> 64 # 13 + 14 + 18 + 18 = 64
```
- 위처럼 아주 간단하게 구간합을 구할 수 있다.