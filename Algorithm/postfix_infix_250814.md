# 후위 표기식과 중위 표기식
## 중위 표기식 (infix)
- 중위 표기식은 사람들이 일반적으로 사용하는 수식의 형태이며 피연산자 사이에 연산자가 존재하는 형태이다. 

>- 4 + 3 또는 5 * 10 + (6 - 2) / 2 등

- 하지만 중위식은 연산자 우선순위나 괄호 등의 문제로 식의 중간부분 부터 계산을 시작해야하는 경우가 많다보니 컴퓨터로 계산하기에는 상당히 껄끄럽다.
- 때문에 컴퓨터로 수식을 계산할 때는 컴퓨터가 계산하기 쉬운 방식으로 수식을 변환시켜줘야 한다.

## 후위 표기식 (postfix)
- 후위 표기식은 컴퓨터가 계산하기 편한 수식 표현방식으로 피연산자가 먼저 나온 뒤 연산자가 마지막에 등장한다. 후위 표기식은 스택을 사용하여 편하게 계산할 수 있다.

>- 4 3 + 또는 5 10 * 6 2 - 2 / + 등 (위의 중위식과 동일한 수식이다.)

## 중위 표기식을 후위 표기식으로 변환
- 중위 표기식을 후위 표기식으로 변환하려면 어떻게 해야 할까
- 먼저 중위 표기식을 순회하면서 피연산자이면 그대로 후위 표기식으로 넣고 연산자의 경우 우선순위에 따라 스택에 집어넣는다. 
    - 연산자 우선순위 (숫자가 높을수록 우선순위가 높음)

        |연산자|     우선순위     |
        |------|-----------------|
        |+, -  |   1             |
        |*, /  |   2             |
        |  (   |3:스택밖 0:스택안|
        |  )   |   -             |

    - 사칙연산은 +, - 보다 *, /가 순위가 더 높고 괄호의 경우 닫는 괄호는 스택 내부로 들어가지 않으므로 순위가 없고 여는 괄호의 경우 약간 특이하다.
    - 여는 괄호는 스택 외부에 있을 때(토큰으로 있을 때)의 경우 우선순위가 가장 높아서 무조건 스택에 들어가지만 스택 내부에서의 우선순위는 0으로 가장 낮다.(다음 연산자는 무조건 들어온다.)
    - 만약 스택의 top에 있는 연산자의 우선순위가 토큰의 우선순위보다 같거나 높다면 top의 연산자가 토큰의 우선순위보다 낮아질 때 까지 스택에서 꺼낸 뒤 표기식 뒤에 붙인다.
    - 그리고 닫는 괄호를 만난다면 스택에서 여는 괄호가 나올 때 까지 계속 연산자를 꺼내서 표기식 뒤에 붙인다. 그리고 닫는 괄호가 나오면 그 괄호는 버린다. 여는 괄호 또한 표기식에 넣지 않는다.
    - 이렇게 중위식을 모두 순회하였으면 스택에 남아있는 연산자를 후위 표기식 뒤쪽에 쭉 붙인다.
- 5 * 10 + ( 6 - 2 ) / 2 를 예로 들자면 중위식이 '5' '*' 이런방식으로 토큰화 되어서 들어온다.
    ```
    token = '5'
    postfix[]
    stack[]
    ```
    ```
    token = '*'
    postfix['5'] # 피연산자는 바로 후위 표기식에 넣는다
    stack[]
    ```
    ```
    token = '10'
    postfix['5']
    stack['*'] # 연산자는 스택이 비어있으면 바로 넣는다
    ```
    ```
    token = '+'
    postfix['5', '10']
    stack['*']
    ```
    ```
    token = '('
    postfix['5', '10', '*']
    stack['+'] # +보다 *의 우선순위가 높으므로 꺼낸뒤 +를 넣는다
    ```
    ```
    token = '6'
    postfix['5', '10', '*']
    stack['+', '(']
    ```
    ```
    token = '-'
    postfix['5', '10', '*', '6']
    stack['+', '(']
    ```
    ```
    token = '2'
    postfix['5', '10', '*', '6']
    stack['+', '(', '-']
    ```
    ```
    token = ')' # 닫는 괄호가 나올 때 까지 pop하고 괄호는 버린다.
    postfix['5', '10', '*', '6', '2']
    stack['+', '(', '-']
    ```
    ```
    token = '/'
    postfix['5', '10', '*', '6', '2', '-']
    stack['+']
    ```
    ```
    token = '2'
    postfix['5', '10', '*', '6', '2', '-']
    stack['+', '/'] # +의 우선순위가 /보다 낮으므로 바로 넣는다
    ```
    ```
    token = ''
    postfix['5', '10', '*', '6', '2', '-', '2']
    stack['+', '/']
    ```
    ```
    token = ''
    postfix['5', '10', '*', '6', '2', '-', '2', '/', '+']
    stack[]

    >> postfix = 5 10 * 6 2 - 2 / +
    ```

## 후위 표기식의 계산
- 위와같이 중위 표기식을 후위 표기식으로 변경 하였으면 이제 계산을 할 차례이다. 
- 후위 표기식은 위에서 스택을 활용해 쉽게 계산할 수 있다고 했는데 그 이유는 다음과 같다.
    - 후위 표기식은 사칙연산이나 괄호에 따른 계산 순서가 적용이 되어있는 상태이기 때문에 앞에서부터 순서대로 연산을 처리하면 된다.
    - 또한 피연산자가 먼저 나오기 때문에 피연산자를 저장해 두었다가 연산자가 나올 때 처리하면 되기 때문에 흐름이 한 방향으로만 이어진다.

- 후위 표기식을 앞에서부터 순회하면서 피연산자이면 스택에 넣고 연산자가 나오면 스택에서 피연산자를 두개 꺼내서 연산을 한 뒤 다시 스택에 넣으면 된다.
- 이때 스택에서 먼저나온 피연산자가 연산자 뒤쪽에서 계산되어야 한다. 
    - 예를 들어 후위 표기식 5 3 - 가 있다면 스택의 상태는 [5, 3]이고 먼저나온 3이 연산자 - 의 뒤쪽으로 가야한다. 즉, 5 - 3 으로 계산해야 한다. 실제로 5 - 3 을 후위 표기식으로 변환하면 5 3 - 가 된다.
- 후위식에 오류가 없다는 가정 하에 모든 계산이 끝나면 스택에는 계산결과만 들어있게 된다.
- 이제 위에서 변환했던 후위식을 실제로 계산해보자
    ```
    >> postfix = 5 10 * 6 2 - 2 / +

    token = '5'
    stack[]
    ```
    ```
    token = '10'
    stack[5]
    ```
    ```
    token = '*'
    stack[5, 10]
    ```
    ```
    token = '6'
    stack[50] << 5*10
    ```
    ```
    token = '2'
    stack[50, 6]
    ```
    ```
    token = '-'
    stack[50, 6, 2]
    ```
    ```
    token = '2'
    stack[50, 4] << 6 - 2
    ```
    ```
    token = '/'
    stack[50, 4, 2]
    ```
    ```
    token = '+'
    stack[50, 2] << 4 / 2
    ```
    ```
    token = ''
    stack[52] << 50 + 2
    ```

- 위처럼 계산이 완료되면 스택에는 계산결과가 들어있게 된다.

- 이제 위의 과정을 코드로 구현해보면 다음과 같다.
    ```python 
    icp = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 3}
    isp = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 0}
    stack = []
    top = -1

    infix = ['5', '*', '10', '+', '(', '6', '-', '2', ')', '/', '2']
    for tok in infix: 
        if tok in ['+', '-', '*', '/']: 
            prio = icp[tok]
            if top == -1: # 스택이 비어있다면 바로 넣음
                stack.append(tok)
                top += 1
            else: 
                while top != -1 and isp[stack[top]] >= prio: # 스택이
                    print(stack.pop(), end=' ') # 비거나 top의 우선순위가 
                    top -= 1                   # 작을 때 까지 반복
                stack.append(tok)
                top += 1
        elif tok == '(': # 여는 괄호는 스택에 바로 넣음(우선순위 가장높음)
            stack.append(tok)
            top += 1
        elif tok == ')': # 여는 괄호가 나올 때 까지 pop
            while stack[top] != '(': 
                print(stack.pop(), end=' ')
                top -= 1
            stack.pop() # 괄호는 버린다.
            top -= 1
        else: # 피연산자는 바로 후위 표기식에 추가
            print(tok, end=' ')
    for _ in range(len(stack)): # 중위 표기식 순회 후 스택에 남아있는
        print(stack.pop(), end=' ') # 연산자 모두 추가
        top -= 1
    
    >> 5 10 * 6 2 - 2 / +
    ```
- 중위 표기식을 후위 표위식으로 변환하는 코드이다.
---
- 이제 변환한 후위 표기식을 계산해보면
    ```python
    postfix = ['5', '10', '*', '6', '2', '-', '2', '/', '+']
    stack = []

    for tok in postfix: 
        if tok.isdecimal(): # 피연산자는 스택에 바로 넣는다.
            stack.append(int(tok)) # 토큰은 str이므로 형변환을 해야 한다.
        else: # 연산자일 경우 스택에서 숫자 두개를 꺼내서 연산 후 다시 
            x2 = stack.pop() # 스택에 넣는다.
            x1 = stack.pop() # 이때 연산순서에 유의해야 한다.
            if tok == '+':   # 먼저 꺼낸 x2가 연산자 뒤로가야 한다.
                result = x1 + x2
            elif tok == '-': 
                result = x1 - x2
            elif tok == '*': 
                result = x1 * x2
            elif tok == '/': 
                result = x1 // x2
            stack.append(result) # 연산 결과를 다시 스택에 넣는다.
    print(result)

    >> 52
    ```
- 숫자는 스택에 넣고 연산자가 나오면 스택에서 숫자를 꺼내 연산후 결과를 다시 스택에 집어넣는 과정을 반복하면 후위식이 계산 가능하다면 계산결과 하나만 남을 것이다.
---
- 만약 후위 표기식이 완전하지 못해 계산하지 못하는 경우는 어떤 케이스가 있을까
- 대략 3가지 경우가 있다. 
    1. 숫자가 연산자보다 모자라거나 순서가 잘못된 경우
    2. 연산자가 숫자보다 모자라는 경우
    3. 피연산자, 연산자 외의 다른 문자가 포함된 경우

- 1번의 경우 연산하기 위해 숫자 두개를 꺼낼 때 스택에 숫자가 1개 이하로 남아있는 상태로 pop을 하게되면 IndexError가 발생하게 된다.
- 2번의 경우 연산을 모두 마친 뒤 스택 내부에 1개 이상의 숫자가 남게 되고 이는 연산에 불필요한 숫자가 포함되어 있다는 뜻이 된다.
- 3번의 경우는 당연히 수식에 들어가면 안되는 문자가 포함되어 있으므로 계산할 수 없다.

- 이외에 당연하게도 수식의 형태는 맞아서 계산은 가능하지만(결과는 나오지만) 연산순서를 틀린다면 계산 결과가 틀릴 수 있다.