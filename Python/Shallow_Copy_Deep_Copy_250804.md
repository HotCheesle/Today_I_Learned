# 얕은 복사 vs 깊은 복사
## 얕은 복사(Shallow copy)
- 파이썬에는 가변 객체(mutable)와 불변 객체(immutable)가 있는데 이 중에서 **가변객체**의 경우 슬라이싱이나 copy()와 같은 방법으로 복사하게 되면 새로운 객체가 생성되기는 하지만 객체 하위 객체의 경우 동일한 객체를 가르키고 있다.
```python
a = [1, 2, 3]
b = a[:]
c = a.copy()

print(id(a))
print(id(b))
print(id(c))

print(id(a[0]))
print(id(b[0]))
print(id(c[0]))
# a와 b와 c자체는 다른 주소를 갖고 있다.
>> 2245843562048
>> 2245843563904
>> 2245843417856

# 하지만 객체 내부의 하위 요소에 대해서는 같은 객체를 가르키고 있다.
>> 140736180941608
>> 140736180941608
>> 140736180941608
```
> 하지만 위처럼 mutable 내에 immutable객체만 있을 때는 얕은 복사를 해도 상관이 없다. 왜냐하면 파이썬의 immutable객체는 재할당이 되면 무조건 새로운 객체로 생성되기 때문에 위에서 일부 객체를 변경한다 해도 서로 영향을 미치지는 않는다.
- 만약 mutable 내에 다른 mutable객체가 있는경우가 이제 문제가 되는데 mutable객체는 일부 수정이 되더라도 객체가 유지되므로 하나를 수정한다면 얕은 복사로 생성한 다른 객체에 영향을 미치게 된다.
```python
a = [1, 2, [3, 4, 5]]
b = a[:]
c = a.copy()

print(id(a[0]))
print(id(b[0]))
print(id(a[2]))
print(id(c[2]))

b[0] = 10
c[2][1] = 20

print(a)
print(b)
print(c)

print(id(a[0]))
print(id(b[0]))

print(id(a[2]))
print(id(c[2]))

# int(불변 객체) 와 list(가변 객체) 현재 모두 같은 객체를 가르키고 있음
>> 140736180941608
>> 140736180941608
>> 2626362546624
>> 2626362546624

# b의 int와 c의 리스트를 변경했는데 리스트는 전체에게 영향을 주었다
>> [1, 2, [3, 20, 5]]
>> [10, 2, [3, 20, 5]]
>> [1, 2, [3, 20, 5]]

# 불변 객체의 경우 값을 수정하니 다른 객체가 생성되었다.
>> 140736180941608
>> 140736180941896

# 가변 객체의 경우 일부 변경이 있어도 객체가 그대로이다.
>> 2626362546624
>> 2626362546624
```
## 깊은 복사(Deep Copy)
- 위와 같은 문제를 해결하려면 mutable객체 이더라도 새로운 객체를 생성하여야 한다. 이를 위한 함수가 바로 `copy.deepcopy()`이다. `copy`모듈에 있는 함수로 사용하려면 `import`를 해야한다.
- 이제 깊은 복사를 통한 복사를 한번 해보자
```python
from copy import deepcopy

a = [1, 2, [3, 4, 5]]
b = deepcopy(a)

print(id(a[2]))
print(id(b[2]))

b[2][1] = 20

print(a)
print(b)

# a와 b내의 mutable 객체도 다른 객체로 새로 생성되어 복사되었다.
>> 3108846050112
>> 3108846057664

# 깊은 복사를 통해 mutable내의 값을 수정해도 더이상 복사한 객체 사이에 영향을 미치지 않는다.
>> [1, 2, [3, 4, 5]]
>> [1, 2, [3, 20, 5]]
```
> 깊은 복사는 mutable객체의 모든 하위 요소에 대하여 값만 같은 새로운 객체를 생성하여 복사본을 생성한다. 이는 원본 객체와 완전히 독립적인 객체가 된다.

> mutable객체 하위에 mutable이 존재할 경우 절대적으로 깊은 복사를 하는것이 안전하다.

## 다차원 리스트 선언에서의 얕은 복사
- 다차원 리스트를 생성할 때 예상치 못하게 얕은 복사 문제가 일어날 수 있는데 바로 시퀀스 연산자를 이용하여 리스트를 생성할 경우이다. 이 경우 시퀀스 연산자는 단순히 동일한 객체를 복사하는 것이므로 얕은 복사가 이루어진다고 볼 수 있다.
```python
from pprint import pprint

arr = [[0] * 5] * 5
pprint(arr)

arr[2][2] = 5
pprint(arr)

# 5*5 2차원 리스트 생성
>> [[0, 0, 0, 0, 0],
>> [0, 0, 0, 0, 0],
>> [0, 0, 0, 0, 0],
>> [0, 0, 0, 0, 0],
>> [0, 0, 0, 0, 0]]

# [2][2]만 변경했음에도 모든 행의 [2]가 바뀐모습
>> [[0, 0, 5, 0, 0],
>> [0, 0, 5, 0, 0],
>> [0, 0, 5, 0, 0],
>> [0, 0, 5, 0, 0],
>> [0, 0, 5, 0, 0]]
```
- 위와같은 현상이 일어난 이유는 각 행의 0을 시퀀스 연산자를 통해 복사한뒤 (이때 0은 list가 아닌 int취급) 해당 리스트를 복사하기 때문에 `[0, 0, 0, 0, 0]` 이라는 동일한 리스트가 다섯번 표시된 것과 같다.
따라서 다차원 배열을 선언할 때에는 가장 하위 요소를 복사할 때를 제외하고는 반드시 `for`문을 통한 리스트 컴프리핸션으로 선언해야 제대로 된 리스트를 선언할 수 있다.